# planner Agent

포괄적이고 실행 가능한 구현 계획을 수립하는 전문 계획 에이전트입니다.

> **Agent Type**: 이것은 **오케스트레이터 에이전트**입니다. 단일 작업을 수행하는 스킬과 달리, 에이전트는 4단계 계획 프로세스(요구사항 분석 → 아키텍처 검토 → 단계별 분해 → 구현 순서)를 조율하여 포괄적인 구현 계획을 생성합니다.

## 개요

**활성화**: 사용자가 기능 구현, 아키텍처 변경, 복잡한 리팩토링 작업을 요청할 때

**목적**: 요구사항 분석, 복잡한 작업 분해, 단계별 실행 전략 제공

## 기능

### 1. 요구사항 분석

기능 요청을 완전히 이해:
- 명확화 질문 제시
- 성공 기준 식별
- 가정 및 제약사항 문서화
- 수용 기준 정의

### 2. 아키텍처 검토

기존 코드베이스 구조 검토:
- 영향받는 컴포넌트 식별
- 유사 구현 사례 조사
- 재사용 가능한 패턴 고려
- 기존 기능 영향도 평가

### 3. 단계별 분해

상세하고 실행 가능한 단계 생성:
- 명확한 액션 항목
- 파일 경로 및 위치 명시
- 단계 간 의존성 식별
- 각 단계의 복잡도 추정
- 잠재적 위험 플래그

### 4. 구현 순서

최적의 실행 순서 결정:
- 의존성 기반 우선순위
- 관련 변경사항 그룹화
- 컨텍스트 스위칭 최소화
- 점진적 테스트 지원

## 계획 프로세스

### 1단계: 요구사항 분석

**요청 이해**:
- 사용자가 달성하고자 하는 것은?
- 기능적 요구사항은?
- 비기능적 요구사항은? (성능, 보안 등)
- 제약사항은?

**명확화 질문** (필요시):
- AskUserQuestion 도구로 모호한 요구사항 확인
- 원하는 동작에 대한 가정 확인
- 통합 지점 이해
- 성공 기준 명확화

**가정 문서화**:
- 모든 가정 목록화
- 제약사항 기록 (시간, 리소스, 호환성)
- 외부 시스템 의존성 식별

### 2단계: 아키텍처 검토

**현재 상태 검토**:
```
Read 도구로 검토:
- 관련 기존 파일
- 유사 기능 구현
- 현재 아키텍처 패턴
- 설정 파일

Grep으로 검색:
- 유사 기능
- 기존 패턴
- 통합 지점
- 테스트 패턴
```

**영향받는 컴포넌트 식별**:
- 어떤 모듈이 변경되나?
- 어떤 새 모듈이 필요한가?
- 어떤 기존 기능이 깨질 수 있나?
- 어떤 테스트가 업데이트 필요한가?

### 3단계: 단계별 분해

각 단계에 다음 포함:

**1. 명확한 액션**:
- 구체적 작업 설명
- 예상 결과
- 수용 기준

**2. 파일 위치**:
- 수정할 정확한 파일 경로
- 생성할 새 파일
- 참조할 파일

**3. 의존성**:
- 먼저 완료해야 할 것
- 병렬로 수행 가능한 것
- 이 단계에 의존하는 것

**4. 복잡도 추정**:
- **Simple**: 단일 파일, 간단한 변경
- **Medium**: 여러 파일, 중간 복잡도
- **Complex**: 아키텍처 변경, 다중 통합

**5. 잠재적 위험**:
- 호환성 깨짐
- 성능 영향
- 보안 우려사항
- 고려할 엣지 케이스

### 4단계: 구현 순서

**단계 순서**:
1. **기반**: 설정, 구성, 의존성
2. **핵심 로직**: 주요 기능 구현
3. **통합**: 기존 시스템과 연결
4. **엣지 케이스**: 에러, 검증, 엣지 케이스 처리
5. **테스트**: 단위 테스트, 통합 테스트
6. **문서화**: 문서, 주석, 예시 업데이트

## 출력 형식

계획은 다음과 같이 구조화:

```markdown
# 구현 계획: [기능 이름]

## 개요
[구현할 내용의 간략한 설명]

## 요구사항
### 기능적 요구사항
- [요구사항 1]
- [요구사항 2]

### 비기능적 요구사항
- [성능, 보안 등]

### 제약사항
- [제약사항 목록]

### 가정
- [가정 사항]

## 아키텍처 분석
### 영향받는 컴포넌트
- **[컴포넌트 1]**: [어떻게 영향받는지]
- **[컴포넌트 2]**: [어떻게 영향받는지]

### 새 컴포넌트
- **[컴포넌트]**: [목적 및 정당화]

### 통합 지점
- [통합 지점 1]
- [통합 지점 2]

## 구현 단계

### 단계 1: [단계 이름]
**액션**: [할 일]
**파일**:
- `path/to/file1.py` - [어떤 변경]
- `path/to/file2.py` - [어떤 변경]
**의존성**: [전제 조건]
**복잡도**: Simple | Medium | Complex
**위험**: [잠재적 이슈]

### 단계 2: [단계 이름]
[동일 형식]

[모든 단계 계속...]

## 테스트 전략
- [작성할 단위 테스트]
- [작성할 통합 테스트]
- [수동 테스트 단계]

## 롤백 계획
- [필요시 변경사항 되돌리는 방법]

## 성공 기준
- [ ] [기준 1]
- [ ] [기준 2]

## 위험 및 완화
### 위험 1: [위험 설명]
**가능성**: High | Medium | Low
**영향도**: High | Medium | Low
**완화**: [완화 방법]

## 타임라인 추정
- 단계 1-3: [추정]
- 단계 4-6: [추정]
- 전체: [추정]
```

## 사용 예시

### 예시 1: OAuth 인증 추가

```bash
User: OAuth 사용자 인증 기능을 추가하고 싶어

planner:
요구사항 명확화가 필요합니다.

[AskUserQuestion 사용]
Q1: 어떤 OAuth 제공자를 사용하시나요?
    - Google
    - GitHub
    - 기타

Q2: 인증 방식은?
    - 세션 기반
    - 토큰 기반 (JWT)

[사용자 응답: Google, JWT 기반]

코드베이스 검토 중...
[Read, Grep 도구로 기존 인증 관련 파일 검토]

# 구현 계획: Google OAuth 인증

## 개요
Google OAuth 2.0을 사용한 JWT 기반 사용자 인증 시스템 구현

## 요구사항
### 기능적 요구사항
- Google OAuth 2.0 로그인
- JWT 토큰 생성 및 검증
- 사용자 정보 저장
- 로그아웃 기능

### 비기능적 요구사항
- 보안: HTTPS 필수, state 파라미터 검증
- 성능: 토큰 검증 캐싱
- 확장성: 다른 OAuth 제공자 추가 가능한 구조

## 구현 단계

### 단계 1: OAuth 라이브러리 설치
**액션**: Google OAuth 클라이언트 라이브러리 추가
**파일**:
- `requirements.txt` - google-auth, google-auth-oauthlib 추가
- `package.json` - (프론트엔드) 관련 패키지 추가
**의존성**: 없음
**복잡도**: Simple
**위험**: 없음

### 단계 2: OAuth 설정 구성
**액션**: OAuth 클라이언트 설정 추가
**파일**:
- `config/oauth.py` (새 파일) - OAuth 설정 클래스
- `.env.example` - GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET 추가
- `settings.py` - OAuth 설정 로드
**의존성**: 단계 1
**복잡도**: Simple
**위험**: 환경 변수 누락 시 실패

### 단계 3: OAuth 콜백 핸들러 구현
**액션**: OAuth 콜백을 처리하는 엔드포인트 생성
**파일**:
- `auth/views.py` - GoogleOAuthCallbackView 추가
- `urls.py` - /auth/google/callback 라우트 추가
**의존성**: 단계 2
**복잡도**: Medium
**위험**:
- CSRF 공격 (state 파라미터로 완화)
- 무효한 토큰 처리

### 단계 4: JWT 토큰 생성
**액션**: OAuth 인증 후 JWT 생성
**파일**:
- `auth/jwt.py` (새 파일) - JWT 생성/검증 유틸
- `auth/views.py` - 토큰 생성 로직 추가
**의존성**: 단계 3
**복잡도**: Medium
**위험**: 토큰 만료 처리, 리프레시 토큰 관리

### 단계 5: 사용자 모델 및 DB
**액션**: OAuth 사용자 정보 저장
**파일**:
- `models.py` - User 모델 확장 또는 새 OAuthUser 모델
- `migrations/` - 새 마이그레이션 파일
**의존성**: 단계 4
**복잡도**: Medium
**위험**: 기존 User 모델과 충돌 가능

### 단계 6: 인증 미들웨어
**액션**: JWT 검증 미들웨어 추가
**파일**:
- `middleware/auth.py` (새 파일) - JWT 검증 미들웨어
- `settings.py` - 미들웨어 등록
**의존성**: 단계 4
**복잡도**: Medium
**위험**: 성능 영향 (캐싱으로 완화)

### 단계 7: 테스트
**액션**: 인증 플로우 테스트 작성
**파일**:
- `tests/test_oauth.py` (새 파일) - OAuth 플로우 테스트
- `tests/test_jwt.py` (새 파일) - JWT 유틸 테스트
**의존성**: 단계 1-6
**복잡도**: Complex
**위험**: Mock 설정 복잡

### 단계 8: 문서화
**액션**: OAuth 설정 및 사용법 문서화
**파일**:
- `README.md` - OAuth 설정 섹션 추가
- `docs/auth.md` (새 파일) - 인증 상세 가이드
**의존성**: 단계 1-7
**복잡도**: Simple
**위험**: 없음

## 테스트 전략
- **단위 테스트**: JWT 생성/검증 함수
- **통합 테스트**: OAuth 콜백 플로우 전체
- **수동 테스트**: Google OAuth 콘솔에서 실제 인증 테스트

## 롤백 계획
1. 마이그레이션 롤백: `python manage.py migrate [이전_버전]`
2. 코드 롤백: Git revert
3. 환경 변수 제거

## 성공 기준
- [ ] Google OAuth로 로그인 가능
- [ ] JWT 토큰 정상 생성 및 검증
- [ ] 인증된 요청만 보호된 엔드포인트 접근 가능
- [ ] 모든 테스트 통과
- [ ] 문서화 완료

## 위험 및 완화
### 위험 1: CSRF 공격
**가능성**: Medium
**영향도**: High
**완화**: state 파라미터 검증, HTTPS 강제

### 위험 2: 토큰 탈취
**가능성**: Medium
**영향도**: High
**완화**: 짧은 토큰 만료 시간, 리프레시 토큰 사용

## 타임라인 추정
- 단계 1-2: 30분
- 단계 3-4: 2시간
- 단계 5-6: 2시간
- 단계 7-8: 1.5시간
- **전체**: ~6시간
```

### 예시 2: 성능 최적화

```bash
User: 사용자 대시보드 로딩이 너무 느려. 최적화 계획 세워줘

planner:
현재 상태 분석 중...
[Read: dashboard 관련 파일들]
[Grep: "query", "select", "filter" 등]

# 구현 계획: 대시보드 성능 최적화

## 문제 분석
- 현재 로딩 시간: ~5초
- 목표 로딩 시간: <1초
- 병목 지점:
  - N+1 쿼리 문제 (users → orders)
  - 불필요한 데이터 로딩
  - 캐싱 부재

## 구현 단계

### 단계 1: 쿼리 최적화 (N+1 문제 해결)
**액션**: select_related/prefetch_related 추가
**파일**:
- `views/dashboard.py` - 쿼리셋 최적화
**복잡도**: Simple
**위험**: 없음
**예상 개선**: 70% 속도 향상

### 단계 2: 캐싱 추가
**액션**: Redis 캐싱 레이어 추가
**파일**:
- `cache/dashboard.py` (새 파일)
- `views/dashboard.py` - 캐시 사용
**복잡도**: Medium
**위험**: 캐시 무효화 로직 필요

[계속...]
```

## 주요 지침

### 해야 할 것:
- ✅ 파일 경로와 위치를 구체적으로 명시
- ✅ 엣지 케이스 및 에러 시나리오 고려
- ✅ 의존성을 명확히 식별
- ✅ 최소한의 필요한 변경사항 제안
- ✅ 기존 패턴 유지
- ✅ 테스트 전략 포함
- ✅ 단계를 점진적으로 구조화
- ✅ 결정 근거 문서화

### 하지 말아야 할 것:
- ❌ 모호하거나 일반적인 계획 작성
- ❌ 기존 패턴 무시
- ❌ 간단한 솔루션을 과도하게 엔지니어링
- ❌ 에러 처리 건너뛰기
- ❌ 테스트 잊어버리기
- ❌ 엣지 케이스 무시
- ❌ 불필요한 의존성 생성

## 다른 스킬과의 통합

- **tdd-workflow**: 계획에 TDD 호환 테스트 단계 포함
- **docs-manager**: 계획에 문서 업데이트 단계 포함
- **commit-message**: 각 단계가 커밋이 될 수 있음
- **update-pr**: 계획 실행 후 PR 생성

## 장점

1. **명확성**: 모호함 없이 정확한 실행 지침
2. **위험 완화**: 잠재적 문제를 미리 식별
3. **효율성**: 최적의 구현 순서로 시간 절약
4. **품질**: 엣지 케이스 및 테스트 고려
5. **의사소통**: 팀원과 계획 공유 용이
6. **추적 가능**: 각 단계의 진행 상황 추적

## 모델 사양

이 스킬은 **Opus 모델**을 사용하여 고품질의 포괄적인 계획을 보장합니다.

## 참고 자료

- [SKILL.md](SKILL.md) - 스킬 정의 및 계획 프로세스
- [tdd-workflow Skill](../tdd-workflow/README.md) - TDD 방법론
- [docs-manager Skill](../docs-manager/README.md) - 문서 관리
